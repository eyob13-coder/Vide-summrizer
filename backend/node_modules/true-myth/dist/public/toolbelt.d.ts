/**
  Tools for working easily with {@linkcode Maybe} and {@linkcode Result}
  *together*... but which do not *require* you to use both. If they were in the
  `true-myth/maybe` or `true-myth/result` modules, then importing either would
  always include the other. While that is not usually a concern with bundlers,
  it *is* an issue when using dynamic imports or otherwise doing runtime
  resolution in a browser or similar environment.

  The flip side of that is: importing from *this* module *does* require access
  to both `Maybe` and `Result` modules.

  @module
 */
import Result from './result.js';
import Maybe from './maybe.js';
/**
  Transposes a {@linkcode Result} of a {@linkcode Maybe} into a `Maybe` of a
  `Result`.

  | Input         | Output         |
  | ------------- | -------------- |
  | `Ok(Just(T))` | `Just(Ok(T))`  |
  | `Err(E)`      | `Just(Err(E))` |
  | `Ok(Nothing)` | `Nothing`      |

  @param result a `Result<Maybe<T>, E>` to transform to a `Maybe<Result<T, E>>`.
 */
export declare function transposeResult<T, E>(result: Result<Maybe<T>, E>): Maybe<Result<T, E>>;
/**
  Convert a {@linkcode Result} to a {@linkcode Maybe.Maybe Maybe}.

  The converted type will be {@linkcode Maybe.Just Just} if the `Result` is
  {@linkcode Ok} or {@linkcode Maybe.Nothing Nothing} if the `Result` is
  {@linkcode Err}; the wrapped error value will be discarded.

  @param result The `Result` to convert to a `Maybe`
  @returns      `Just` the value in `result` if it is `Ok`; otherwise `Nothing`
 */
export declare function toMaybe<T>(result: Result<T, unknown>): Maybe<T>;
/**
  Transform a {@linkcode true-myth.maybe!Maybe Maybe} into a {@linkcode Result}.

  If the `Maybe` is a {@linkcode true-myth.maybe!Just Just}, its value will be wrapped in
  the {@linkcode Ok} variant; if it is a {@linkcode Maybe.Nothing Nothing} the
  `errValue` will be wrapped in the {@linkcode Err} variant.

  @param errValue A value to wrap in an `Err` if `maybe` is a `Nothing`.
  @param maybe    The `Maybe` to convert to a `Result`.
 */
export declare function fromMaybe<T, E>(errValue: E, maybe: Maybe<T>): Result<T, E>;
export declare function fromMaybe<T, E>(errValue: E): (maybe: Maybe<T>) => Result<T, E>;
/**
  Transposes a {@linkcode Maybe} of a {@linkcode Result} into a `Result` of a
  `Maybe`.

  | Input          | Output        |
  | -------------- | ------------- |
  | `Just(Ok(T))`  | `Ok(Just(T))` |
  | `Just(Err(E))` | `Err(E)`      |
  | `Nothing`      | `Ok(Nothing)` |

  @param maybe a `Maybe<Result<T, E>>` to transform to a `Result<Maybe<T>, E>>`.
 */
export declare function transposeMaybe<T, E>(maybe: Maybe<Result<T, E>>): Result<Maybe<T>, E>;
/**
  Transform the {@linkcode Maybe} into a {@linkcode Result.Result Result}, using
  the wrapped value as the `Ok` value if `Just`; otherwise using the supplied
  `error` value for `Err`.

  @typeparam T  The wrapped value.
  @typeparam E  The error type to in the `Result`.
  @param error The error value to use if the `Maybe` is `Nothing`.
  @param maybe The `Maybe` instance to convert.
  @returns     A `Result` containing the value wrapped in `maybe` in an `Ok`, or
               `error` in an `Err`.
 */
export declare function toOkOrErr<T, E>(error: E, maybe: Maybe<T>): Result<T, E>;
export declare function toOkOrErr<T, E>(error: E): (maybe: Maybe<T>) => Result<T, E>;
/**
  Transform the {@linkcode Maybe} into a {@linkcode Result}, using the wrapped
  value as the `Ok` value if `Just`; otherwise using `elseFn` to generate `Err`.

  @typeparam T  The wrapped value.
  @typeparam E  The error type to in the `Result`.
  @param elseFn The function which generates an error of type `E`.
  @param maybe  The `Maybe` instance to convert.
  @returns     A `Result` containing the value wrapped in `maybe` in an `Ok`, or
               the value generated by `elseFn` in an `Err`.
 */
export declare function toOkOrElseErr<T, E>(elseFn: () => E, maybe: Maybe<T>): Result<T, E>;
export declare function toOkOrElseErr<T, E>(elseFn: () => E): (maybe: Maybe<T>) => Result<T, E>;
/**
  Construct a {@linkcode Maybe Maybe<T>} from a
  {@linkcode Result.Result Result<T, E>}.

  If the `Result` is an `Ok`, wrap its value in `Just`. If the `Result` is an
  `Err`, throw away the wrapped `E` and transform to a {@linkcode Nothing}.

  @typeparam T  The type of the value wrapped in a `Result.Ok` and in the `Just`
                of the resulting `Maybe`.
  @param result The `Result` to construct a `Maybe` from.
  @returns      `Just` if `result` was `Ok` or `Nothing` if it was `Err`.
 */
export declare function fromResult<T>(result: Result<T, unknown>): Maybe<T>;
//# sourceMappingURL=toolbelt.d.ts.map