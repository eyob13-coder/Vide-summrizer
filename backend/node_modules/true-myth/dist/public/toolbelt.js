/**
  Tools for working easily with {@linkcode Maybe} and {@linkcode Result}
  *together*... but which do not *require* you to use both. If they were in the
  `true-myth/maybe` or `true-myth/result` modules, then importing either would
  always include the other. While that is not usually a concern with bundlers,
  it *is* an issue when using dynamic imports or otherwise doing runtime
  resolution in a browser or similar environment.

  The flip side of that is: importing from *this* module *does* require access
  to both `Maybe` and `Result` modules.

  @module
 */
import Result from './result.js';
import Maybe from './maybe.js';
import { curry1 } from '../-private/utils.js';
/**
  Transposes a {@linkcode Result} of a {@linkcode Maybe} into a `Maybe` of a
  `Result`.

  | Input         | Output         |
  | ------------- | -------------- |
  | `Ok(Just(T))` | `Just(Ok(T))`  |
  | `Err(E)`      | `Just(Err(E))` |
  | `Ok(Nothing)` | `Nothing`      |

  @param result a `Result<Maybe<T>, E>` to transform to a `Maybe<Result<T, E>>`.
 */
export function transposeResult(result) {
    return result.match({
        Ok: (maybe) => maybe.match({
            Just: (v) => Maybe.just(Result.ok(v)),
            Nothing: () => Maybe.nothing(),
        }),
        Err: (e) => Maybe.just(Result.err(e)),
    });
}
/**
  Convert a {@linkcode Result} to a {@linkcode Maybe.Maybe Maybe}.

  The converted type will be {@linkcode Maybe.Just Just} if the `Result` is
  {@linkcode Ok} or {@linkcode Maybe.Nothing Nothing} if the `Result` is
  {@linkcode Err}; the wrapped error value will be discarded.

  @param result The `Result` to convert to a `Maybe`
  @returns      `Just` the value in `result` if it is `Ok`; otherwise `Nothing`
 */
export function toMaybe(result) {
    return result.isOk ? Maybe.just(result.value) : Maybe.nothing();
}
export function fromMaybe(errValue, maybe) {
    const op = (m) => (m.isJust ? Result.ok(m.value) : Result.err(errValue));
    return curry1(op, maybe);
}
/**
  Transposes a {@linkcode Maybe} of a {@linkcode Result} into a `Result` of a
  `Maybe`.

  | Input          | Output        |
  | -------------- | ------------- |
  | `Just(Ok(T))`  | `Ok(Just(T))` |
  | `Just(Err(E))` | `Err(E)`      |
  | `Nothing`      | `Ok(Nothing)` |

  @param maybe a `Maybe<Result<T, E>>` to transform to a `Result<Maybe<T>, E>>`.
 */
export function transposeMaybe(maybe) {
    return maybe.match({
        Just: (result) => result.match({
            Ok: (v) => Result.ok(Maybe.just(v)),
            Err: (e) => Result.err(e),
        }),
        Nothing: () => Result.ok(Maybe.nothing()),
    });
}
export function toOkOrErr(error, maybe) {
    const op = (m) => (m.isJust ? Result.ok(m.value) : Result.err(error));
    return maybe !== undefined ? op(maybe) : op;
}
export function toOkOrElseErr(elseFn, maybe) {
    const op = (m) => (m.isJust ? Result.ok(m.value) : Result.err(elseFn()));
    return curry1(op, maybe);
}
/**
  Construct a {@linkcode Maybe Maybe<T>} from a
  {@linkcode Result.Result Result<T, E>}.

  If the `Result` is an `Ok`, wrap its value in `Just`. If the `Result` is an
  `Err`, throw away the wrapped `E` and transform to a {@linkcode Nothing}.

  @typeparam T  The type of the value wrapped in a `Result.Ok` and in the `Just`
                of the resulting `Maybe`.
  @param result The `Result` to construct a `Maybe` from.
  @returns      `Just` if `result` was `Ok` or `Nothing` if it was `Err`.
 */
export function fromResult(result) {
    return result.isOk ? Maybe.just(result.value) : Maybe.nothing();
}
//# sourceMappingURL=toolbelt.js.map